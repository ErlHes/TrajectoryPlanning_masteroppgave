{"rule":"THE_BEST_WAY","sentence":"^\\QWhen using this algorithm in a canal crossing situation the dynamic horizon distance could be tuned way down from its normal 5-minute horizon, which would reduce the time to solve the NLP significantly.\\E$"}
{"rule":"LIGATURES","sentence":"^\\Qskjærgård without Traffic.\\E$"}
{"rule":"LIGATURES","sentence":"^\\QSkjærgård with Traffic.\\E$"}
{"rule":"LIGATURES","sentence":"^\\QSkjærgård with traffic situation.\\E$"}
{"rule":"SUBJECT_MATTER","sentence":"^\\QI would like to thank my supervisors Morten Breivik and Emil Thryi, without whom I would have never been able to fully understand and transform the subject matter into something worth writing about.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QFigures for the thesis were drawn using Inkscape and Draw.io.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QLastly I would like to thank Olex AS for letting me use their software to store AIS data over the course of a few days to get a look at the ocean traffic along the Norwegian coast.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QErlend Hestvik 11.06.2022\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\QThe data in the tracks struct is parsed through a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q assessment algorithm to determine if any of the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qs need to be considered an active dynamic obstacle.\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\QFor testing and debugging purposes the tracks structure can be modified to emulate the form factor of a simple prediction level, in a real implementation the simplification should not be necessary as the data in the tracks struct should already be in the correct format for either prediction level.\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\QFeasibility, time horizon and discretization step information is then used to generate a reference trajectory for the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, a trajectory is also generated for all the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q in the tracks struct, which are used to place dynamic constraints later.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QFunction: Initialize persistent variable persistent Var isempty(Var) Var \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Initial value\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QOne for storing a variable called firsttime, used to execute code only the first time the algorithm is called.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QOne for storing a variable called firsttime, used to execute code only the first time the algorithm is called.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe pose and velocity vectors are combined as one SX.sym vector, while the forces and toruqe is made separately.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QIf you are wondering why the system is initialized with SX.sym but the RK4 method uses MX.sym I have no answer; CasADi's example pack includes an example for direct multiple shooting, that example includes an RK4 method on the form shown above.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QSince my algorithm uses the direct multiple shooting example as a skeleton this RK4 method with MX.sym was carried along until the final version.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QUsing the general algorithm, the shooting gap constraints look like this as an example: where Xkend is the end of the previous integration step and Xk are the newest decision variables, this will be discussed soon.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThis is done by checking the difference between headingref - initialheading versus wrapTo2Pi(headingref) - initial heading.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QFor every k after 0 The heading reference is kept in the correct sign with the following code: where ssa() is the shortest signed angle of the difference, and previousetaref(3) is the heading reference from the previous control interval.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe general implementation for placing a constraint is the following function: General function for placing dynamic constraint origin point Offsetangle \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q atan2(TS.traj(4,k+1) , TS.traj(3,k+1)) + offset Offsetdir \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q [ cos(Offsetangle) , sin(Offsetangle) ] odc \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q TS.traj(1:2 , k+1) + Offsetdist * Offsetdir   where offset is the angle offset from the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q's heading, and the Offsetdist is the distance from the center of the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to the placement of the constraint origin point.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe first is options.ipopt.maxiter, which lets us set a hardcap on how many iterations the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q solver is allowed to use.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe second option is the options.ipopt.printlevel, which controls how much information is printed to the command window, this has no actual effect solver, but printing to command window takes time.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QIn the final version of the algorithm I've set options.ipopt.maxiter to 200 for the first time the algorithm runs, and 400 for the rest.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThis guidance method is perhaps the most intuitive; consider the waypoints WPk and WPk+1, the simplest path from one to the other would be straight line.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe equation for \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q then become: \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q where Kp and Ki are gain parameters proportional to the lookahead distance, typically \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q with \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q being some design variable.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QIn another study, (\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) attempts to predict the trajectory of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qs via an estimation scheme consisting of a Long Short-term Memory model in a Generative Adverserial Network configuration.\\E$"}
